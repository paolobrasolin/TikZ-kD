% tikzlibrarykD.core.code.tex
%
% Copyright 2015 by Paolo Brasolin <paolo.brasolin@gmail.com>
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.

% ######################################################################## SOF #

% Default settings
\pgfqkeys{/kD}{
%
  fallback/.code={
    \let\searchname=\pgfkeyscurrentname%
    \pgfkeysalso{
      /tikz/\searchname/.try=#1,
      /tikz/node math contents/.retry/.expand once=\searchname}},
%
  objects/.unknown/.style={/kD/fallback=#1},
  arrows/.search also=/tikz,
  labels/.unknown/.style={/kD/fallback=#1},
  lattices/.search also=/tikz,
%
  current object/.style={},
  current arrow/.style={},
  current label/.style={},
  current lattice/.style={},
%
  current chain/every arrow/.style={},
  current chain/every label/.style={},
%
  every object/.style={
    self naming node,},
  every arrow/.style={},
  every label/.style={
    self naming node,
    auto,
    /tikz/inner sep=+0.5ex,
    /tikz/font=\everymath\expandafter{\the\everymath\scriptstyle},},
  every lattice/.style={},
%
  /kD/arrows/.cd,
    ->/.style={-Stealth},
  /kD/lattices/.cd,
    rectangular/.style 2 args={
      /tikz/column sep={#1,between origins},
      /tikz/row sep={#2,between origins},},
    square/.style={rectangular={#1}{#1},},
    golden/.style={rectangular={1.618*#1}{#1},},
    comb/.style={
      rectangular={sqrt(4/3)*#1}{#1},
      /tikz/every odd row/.style={xshift=tan(30)*#1},},
    comb/.default=4em,
    square/.default=4em,
    golden/.default=4em,
  /kD/arrows/.cd,
    l>/.style={bend right,->},
    r>/.style={bend left,->},
    crossing over/.style={preaction={-,
      draw=\pgfkeysvalueof{/kD/arrows/crossing over/color},
      line width=\pgfkeysvalueof{/kD/arrows/crossing over/clearance},},},
    crossing over/clearance/.initial=0.236em,
    crossing over/color/.initial=white,
    รท/.style={crossing over},
    รท>/.style={รท,->},
    shift/.style={transform canvas=
      {shift={($(\tikztostart)!#1!-90:(\tikztotarget)-(\tikztostart)$)}}},
    slide/.style={transform canvas=
      {shift={($(\tikztostart)!#1!0:(\tikztotarget)-(\tikztostart)$)}}},
  /kD/labels/.cd,
    mid/.style={inner sep=1.5pt,shape=circle,fill=white,anchor=center},
    </.style={near start},
    >/.style={near end},}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pgfqkeys{/handlers}{
  first char syntax=true,
  first char syntax/.cd,
  the character (/.initial=\kDNamingShortcut,
  the character "/.initial=\kDContentShortcut,}

\def\kDRemoveRoundParentheses(#1){#1}
\def\kDRemoveDoubleQuotes"#1"{#1}

% A conditional here would be nice (do alias iff name is empty) but unnecessary
\def\kDNamingShortcut#1{\pgfkeysalso{
  /tikz/name/.expand once={\kDRemoveRoundParentheses#1},
  /tikz/alias/.expand once={\kDRemoveRoundParentheses#1},}}

\def\kDContentShortcut#1{\pgfkeysalso{
  /tikz/node math contents/.expand once={\kDRemoveDoubleQuotes#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tikzset{
  /tikz/node math contents/.style={/tikz/node contents={$#1$}}
}

\pgfqkeys{/kD/parse}{
%
  bisect/.code args={#1at#2into#3and#4}{%
    \kDBisect#1\at#2\into#3\and#4\GO},
%
  /tikz/edge node string/.code args={[#1]#2}{
    \ifx\relax#1\relax\else\tikzset{edge node={node[/kD/parse/label={#1},/kD/render/label]}}\fi%
    \ifx\relax#2\relax\else\tikzset{edge node string={#2}}\fi},
%
  object/.forward to=/kD/current object/.style,
  arrow/.forward to=/kD/current arrow/.style,
  label/.forward to=/kD/current label/.style,
  lattice/.forward to=/kD/current lattice/.style,
  morphism/.style={
    /kD/parse/bisect={#1}at{:}into{kDSND}and{kDFST},
    /kD/parse/arrow/.expand once=\kDSND,
    /kD/parse/labels/.expand once=\kDFST,},
  chain/.style={
    /kD/parse/bisect={#1}at{:}into{kDSND}and{kDFST},
    /kD/current chain/every arrow/.estyle=\kDSND,
    /kD/current chain/every label/.estyle=\kDFST,},
  labels/.code={%
    \ifx\relax#1\relax\else%
    \def\doit##1##2\GO{\def\tmp{##1}}\def\sqr{[}\doit#1\GO%
    \ifx\tmp\sqr%
      \pgfkeysalso{/kD/current arrow/.append style={edge node string={#1}}}\else%
      \pgfkeysalso{/kD/current arrow/.append style={edge node string={[#1]}}}\fi%
    \fi},
}

\pgfqkeys{/kD/render}{
  object/.style={
    /kD/objects/.cd,
    /kD/every object,
    /kD/current object,},
  morphism/.style={
    /kD/arrows/.cd,
    /kD/every arrow,
    /kD/current chain/every arrow,
    /kD/current arrow,},
  label/.style={
    /kD/labels/.cd,
    /kD/every label,
    /kD/current chain/every label,
    /kD/current label,},
  lattice/.style={
    /kD/lattices/.cd,
    /kD/every lattice,
    /kD/current lattice,},}

% =========================================================== arrow keys: CHOP =

%\def\kDChopParse#1|#2|#3\GO%
%  {\kDBalancerInit\pgfdecoratedpathlength
%   \kDBalancerTally#1\to One\GO
%   \kDBalancerTally#2\to Two\GO
%   \kDBalancerTally#3\to Thr\GO
%   \expandafter\kDBalancerGauge\One\to Fst\GO
%   \expandafter\kDBalancerGauge\Thr\to Lst\GO
%   \pgfmathsetmacro\start{\Fst}
%   \pgfmathsetmacro\stop{1-\Lst}}
%
%
%\tikzset{/kD/arrows/chop/.style={ 
%  decoration={ 
%    show path construction, 
%    curveto code={
%      \kDFullExpandAfter\kDChopParse{#1}\GO
%      \pgfpathcurvebetweentime{\start}{\stop}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentsupporta}
%      {\pgfpointdecoratedinputsegmentsupportb}
%      {\pgfpointdecoratedinputsegmentlast}},
%    lineto code={
%      \kDFullExpandAfter\kDChopParse{#1}\GO
%      \pgfpathcurvebetweentime{\start}{\stop}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentfirst}
%      {\pgfpointdecoratedinputsegmentlast}
%      {\pgfpointdecoratedinputsegmentlast}}
%  },decorate},
%  % the following key has to be integrated into the syntax of the main key
%  /kD/arrows/schop/.style={/kD/arrows/chop=#1|*|#1},
%}

% ========================================================== PARAMETER PARSING =

\def\kDDoObject#1\GO%
  {\node [/kD/parse/object={#1}, /kD/render/object];}

\def\kDDoMorphism#1 #2 #3\GO%
  {\path (#1) edge [/kD/parse/morphism={#2}, /kD/render/morphism] (#3);}

%\let\kDThisSource\relax \let\kDLastSource\relax
%\let\kDThisTarget\relax \let\kDLastTarget\relax
%\def\kDLast{*}

\def\kDDoMorphismChain#1 #2 #3 #4\GO%
  {%\def\kDSource{#1}\ifx\kDSource\kDLast\let\kDSource\kDLastSource\fi
   %\def\kDTarget{#3}\ifx\kDTarget\kDLast\let\kDTarget\kDLastTarget\fi
   \kDDoMorphism{#1} {#2} {#3}\GO%
   %\ifx\kDThisSource\relax\let\kDThisSource\kDSource\fi
   \ifx\relax#4\relax%
   %\let\kDLastSource\kDThisSource\let\kDThisSource\relax
   %\let\kDLastTarget\kDTarget
   \else\kDDoMorphismChain{#3} #4\GO%
   \fi}

\def\kDDoMorphismChainWithoutOptions #1;%
  {\kDDoMorphismChainWithOptions[] #1;}

\def\kDDoMorphismChainWithOptions[#1] #2;%
  {\pgfqkeys{/kD/parse}{chain={#1}}%
   \kDDoMorphismChain#2 \GO}

% ============================================================= USER INTERFACE =

\def\obj#1;%
  {\kDDoObject#1\GO}

\kDDefOptional mor\with%
  \kDDoMorphismChainWithOptions\and%
  \kDDoMorphismChainWithoutOptions\GO

\def\lattice[#1]%
  {\matrix [/kD/parse/lattice={#1}, /kD/render/lattice] }

% ######################################################################## EOF #
